<!--Author: Samuel Johnson (SmashMaster)-->
<!--Copyright: 2014 Samuel Johnson-->
<!--License: https://github.com/SmashMaster/smashmaster.github.io/blob/master/LICENSE-->
<!DOCTYPE html>
<html>

<head>
<title>Sam's Website</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

<style type="text/css">
#webglcanvas {
    background: #000; /*Put fallback image here*/
    width: 100%;
    height: 600px;
    border: none;
    vertical-align: bottom;
    line-height: 1px;
}

body {
    background: #0d0d0d;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 18px;
    color: #c4c4c4;
    margin: 0px auto;
    min-width: 500px;
    max-width: 1200px;
}

h2 {
    font-weight: bold;
}

/*MAIN MENU*/
.accordion {
    display: inline-block;
    background-color: #1f1f1f;
    margin: 0px auto;
    width: 100%;
    vertical-align: bottom;
}
.accordion dd {
    display: none;
    text-align: center;
    margin: 0px auto;
}
.accordion dt {
    background-color: #505050;
    font-size: 32px;
    line-height: 36px;
    font-weight: bold;
    text-align: center;
}
.accordion dt .fa {
    display:block;
    font-size: 16px;
    line-height: 18px;
}
.accordion dt:hover {
    background-color: #7c7c7c;
    color: #ededed;
    cursor: pointer;
}
.accordion dt.accordion-active {
    background-color: #6495bb;
    color: #ededed;
}
.accordion dt.accordion-active:hover {
    cursor: default;
}

/*MENU CHEVRONS*/
.accordion dt:before {
    font-family:'FontAwesome'; content: "\f105"; margin-left: 120px; width: 32px; float: left;
}
.accordion dt:after {
    font-family:'FontAwesome'; content: "\f104"; margin-right: 120px; width: 32px; float: right;
}
.accordion dt.accordion-active:before {
    content: "\f107";
}
.accordion dt.accordion-active:after {
    content: "\f107";
}

#footer {
    background-color: #1f1f1f;
    text-align: center;
}

/*LINK COLORS*/
a:link    {color: #6495bb;}
a:visited {color: #6495bb;}
a:hover   {color: #ededed;}
a:active  {color: #ffffff;}
</style>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="accordion.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform float u_aspectRatio;
    uniform sampler2D u_tex_clouds;
    
    varying vec2 v_pos;

    void main(void) {
        vec3 rayDir = normalize(vec3(v_pos.x, v_pos.y*u_aspectRatio, -1.0));
        
        gl_FragColor = vec4(texture2D(u_tex_clouds, v_pos*0.5 + 0.5).rgb,  1.0);
        //gl_FragColor = vec4(rayDir*0.5 + 0.5, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 in_pos;
    
    varying vec2 v_pos;

    void main(void) {
        v_pos = in_pos;
        gl_Position = vec4(in_pos, 0.0, 1.0);
    }
</script>

<script type="text/javascript">
    var gl;
    var cloudTexture;
    
    /*requestAnimationFrame polyfill - https://gist.github.com/paulirish/1579671 */
    (function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
 
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }());
    
    /*addevent polyfill - https://gist.github.com/paulirish/1579671 */
    function addEvent(elem, type, eventHandle) {
        if (elem == null || typeof(elem) == 'undefined') return;
        if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );
        } else if ( elem.attachEvent ) {
            elem.attachEvent( "on" + type, eventHandle );
        } else {
            elem["on"+type]=eventHandle;
        }
    }
    
    function onResize() {
        if (!gl) return;
        
        gl.viewportWidth = gl.canvas.width;
        gl.viewportHeight = gl.canvas.height;
    };
    
    function handleTextureLoaded(image, texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    
    function initTextures() {
        cloudTexture = gl.createTexture();
        var cloudImage = new Image();
        $(cloudImage).one('load', function() {
            handleTextureLoaded(cloudImage, cloudTexture);
        });
        cloudImage.src = "clouds.png";
    }
    
    function getShader(id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader("shader-fs");
        var vertexShader = getShader("shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "in_pos");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_aspectRatio"), gl.viewportHeight/gl.viewportWidth);
        gl.uniform1i(gl.getUniformLocation(shaderProgram, "u_tex_clouds"), 0);
    }

    var fsqBuffer;

    function initBuffers() {
        fsqBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, fsqBuffer);
        vertices = [
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
             1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        fsqBuffer.itemSize = 2;
        fsqBuffer.numItems = 4;
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, fsqBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, fsqBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, cloudTexture);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, fsqBuffer.numItems);
    }

    function main() {
        var canvas = document.getElementById("webglcanvas");
        try {
            gl = canvas.getContext("experimental-webgl");
            onResize();
            initTextures();
            initShaders();
            initBuffers();
        } catch (e) {
            alert(e);
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        addEvent(window, "resize", onResize);
        (function animloop(){
            window.requestAnimationFrame(animloop);
            drawScene();
        })();
        
    }
</script>
</head>

<body onload="main();">
<canvas id="webglcanvas" width="1200px" height="600px"></canvas>
<dl class="accordion">
    <dt>About</dt>
    <dd>
        <p>All about sam</p>
        <p>More about sam</p>
        <p>Even more about sam</p>
    </dd>
    <dt>Skills</dt>
    <dd>
        <p>Stuff I'm good at</p>
    </dd>
    <dt>Projects</dt>
    <dd>
        <p>Link to my GitHub</p>
    </dd>
    <dt>Contact</dt>
    <dd>
        <p>Contact info</p>
    </dd>
</dl>
<div id="footer">
&copy 2014 Sam Johnson<br>
<a href="https://github.com/SmashMaster/smashmaster.github.io">This website is open source and published under the MIT license.</a>
</div>
</body>

</html>

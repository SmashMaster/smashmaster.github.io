<!--Author: Samuel Johnson (SmashMaster)-->
<!--Copyright: 2014 Samuel Johnson-->
<!--License: https://github.com/SmashMaster/smashmaster.github.io/blob/master/LICENSE-->
<!DOCTYPE html>
<html>

<head>
<title>Sam's Website</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Prociono">
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Raleway:300">
<link rel="stylesheet" type="text/css" href="style.css">

<script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="accordion.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision lowp float;
    
    uniform float u_time;
    uniform float u_canvasHeight;
    uniform float u_pageOffsetY;
    uniform float u_aspectRatio;
    uniform sampler2D u_tex_clouds;
    uniform sampler2D u_tex_name;
    
    varying vec2 v_pos;
    
    const float CAMERA_HEIGHT = 0.125;
    const float Z_CLIP_NEAR = 0.0625;
    const float ATMOSPHERIC_DENSITY = 0.05;
    const vec3 ATMOSPHERIC_ATTENUATION = vec3(0.06, 0.09, 0.1);
    const vec3 ATMOSPHERIC_INSCATTERING = vec3(0.06, 0.09, 0.1);
    
    float intersectPlaneY(vec3 rayPos, vec3 rayDir, float planeY) {
        return (planeY - rayPos.y)/rayDir.y;
    }
    
    float intersectPlaneZ(vec3 rayPos, vec3 rayDir, float planeZ) {
        return (planeZ - rayPos.z)/rayDir.z;
    }
    
    void atmAttenuate(in float opticalDepth, inout vec3 luminance) {
        vec3 t = exp(-opticalDepth*ATMOSPHERIC_DENSITY*ATMOSPHERIC_ATTENUATION);
        luminance = mix(ATMOSPHERIC_INSCATTERING, luminance, t);
    }
    
    /*NAME*/
    
    const float NAME_DISTANCE = 1.0;
    const float NAME_SCALE = 0.125;
    const float NAME_HEIGHT = 0.07;
    const float NAME_ASPECT_RATIO = 4.0;
    const float NAME_Y_FACTOR = NAME_HEIGHT/NAME_ASPECT_RATIO;
    const vec3 NAME_COLOR = vec3(0.875);
    
    vec3 rayName(vec3 rayPos, vec3 rayDir, float prevT) {
        float t = intersectPlaneZ(rayPos, rayDir, -NAME_DISTANCE);
        
        if (t < 0.0 || t > prevT) {
            return vec3(0.0);
        }
        
        vec3 p = rayPos + rayDir*t;
        vec2 tc = vec2(p.x/NAME_ASPECT_RATIO, NAME_HEIGHT-p.y);
        tc = (tc/NAME_SCALE)*0.5 + 0.5;
        
        if (tc.x < 0.0 || tc.x > 1.0 || tc.y < 0.0 || tc.y > 1.0) return vec3(0.0);
        
        return NAME_COLOR*texture2D(u_tex_name, tc).r;
    }
    
    /*AURORA*/
    
    const float AURORA_HEIGHT = 48.0;
    const float AURORA_SCALE = 512.0;
    const float AURORA_DISTORT_SCALE = 2048.0;
    const float AURORA_DISTORT_AMOUNT = 2.0;
    const float AURORA_BRIGHTNESS = 2.5;
    const vec3 AURORA_COLOR_A = vec3(0.0, 0.9, 0.1);
    const vec3 AURORA_COLOR_B = vec3(0.0, 0.4, 0.6);
    const vec3 AURORA_AVERAGE_COLOR = (AURORA_COLOR_A + AURORA_COLOR_B)*(0.5*AURORA_BRIGHTNESS);
    const float AURORA_FADE_START = 100.0;
    const float AURORA_FADE_END = 750.0;
    const float AURORA_FADE_DIST = AURORA_FADE_END - AURORA_FADE_START;
    
    float auroraDensity(vec3 pos) {
        float t = u_time/64.0;
        vec2 p = vec2(pos.x, pos.z);
        
        vec2 dp = p/AURORA_DISTORT_SCALE;
        float dt = t/16.0;
        vec2 d = vec2(
            texture2D(u_tex_clouds, vec2(dp.x + dt,  dp.y + 0.5)).r, 0.0);
        d = (d*2.0 - 1.0)*AURORA_DISTORT_AMOUNT;
        
        float b = texture2D(u_tex_clouds, p/AURORA_SCALE - t + d).r;
        
        return pow(b, 24.0);
    }
    
    vec3 auroraColor(vec3 pos) {
        pos.xz /= 256.0;
        
        vec2 texCoord = vec2(pos.x + u_time/32.0, pos.z);
        float ct = texture2D(u_tex_clouds, texCoord).r;
        return mix(AURORA_COLOR_A, AURORA_COLOR_B, ct*ct);
    }
    
    vec3 rayAurora(vec3 rayPos, vec3 rayDir) {
        float t = intersectPlaneY(rayPos, rayDir, AURORA_HEIGHT);
        vec3 p = rayPos + rayDir*t;
        float fadeT = clamp((t - AURORA_FADE_START)/AURORA_FADE_DIST, 0.0, 1.0);
        
        vec3 luminance = vec3(0.0);
        
        if (fadeT < 1.0) {
            luminance += ((1.0 - fadeT)*AURORA_BRIGHTNESS*auroraDensity(p))*auroraColor(p);
        }
        if (fadeT > 0.0) {
            luminance += AURORA_AVERAGE_COLOR*(fadeT*0.175);
        }
        
        atmAttenuate(t, luminance);
        luminance += rayName(rayPos, rayDir, t);
        return luminance;
    }
    
    /*WATER*/
    
    const float WATER_DEPTH = 1.0/64.0;
    const float WATER_FADE_START = 0.35;
    const float WATER_FADE_END = 0.025;
    const float WATER_FADE_DIST = WATER_FADE_START - WATER_FADE_END;
    const vec3 WATER_FAR_COLOR = ATMOSPHERIC_INSCATTERING;
    const float WATER_ETA = 1.05;
    
    const float WATER_DENSITY = 60.0;
    const vec3 WATER_ATTENUATION = vec3(0.05, 0.05, 0.05);
    const vec3 WATER_INSCATTERING = vec3(0.05, 0.05, 0.05);
    
    float waterHeight(vec3 pos) {
        float t = u_time/48.0;
        
        pos.x += -1.5*t;
        pos.z += 0.5*t;
    
        return (texture2D(u_tex_clouds, vec2(pos.x + t, pos.z      )).r +
                texture2D(u_tex_clouds, vec2(pos.x - t, pos.z + 0.5)).r +
                texture2D(u_tex_clouds, vec2(pos.x,       pos.z + t)).r +
                texture2D(u_tex_clouds, vec2(pos.x + 0.5, pos.z - t)).r)*0.25;
    }
    
    vec3 waterNormal(vec3 pos) {
        const float D = 1.0/512.0;
        
        float h = waterHeight(pos);
        float hx = waterHeight(vec3(pos.x + D, pos.y, pos.z));
        float hz = waterHeight(vec3(pos.x, pos.y, pos.z + D));
        
        const float F = WATER_DEPTH/D;
        
        return normalize(vec3((h - hx)*F, 1.0, (h - hz)*F));
    }
    
    vec3 rayWaterTop(vec3 rayPos, vec3 rayDir)
    {
        float t = intersectPlaneY(rayPos, rayDir, 0.0);
        vec3 p = rayPos + t*rayDir;
        
        if (p.z > -Z_CLIP_NEAR) return WATER_INSCATTERING;
        
        const vec3 WATER_BASE_NORMAL = vec3(0.0, 1.0, 0.0);
        vec3 baseReflect = reflect(rayDir, WATER_BASE_NORMAL);
        float fadeT = clamp((WATER_FADE_START - baseReflect.y)/WATER_FADE_DIST, 0.0, 1.0);
        
        vec3 luminance = vec3(0.0);
        
        if (fadeT < 1.0) {
            vec3 n = waterNormal(p);
            vec3 ref = reflect(rayDir, n);
            
            if (ref.y > 0.0) {
                luminance += (1.0 - fadeT)*rayAurora(p, ref);
            }
        }
        if (fadeT > 0.0) {
            luminance += fadeT*WATER_FAR_COLOR;
        }
        
        atmAttenuate(t, luminance);
        luminance += rayName(rayPos, rayDir, t);
        return luminance;
    }
    
    void watAttenuate(in float opticalDepth, inout vec3 luminance) {
        vec3 t = exp(-opticalDepth*WATER_DENSITY*WATER_ATTENUATION);
        luminance = mix(WATER_INSCATTERING, luminance, t);
    }
    
    vec3 rayWaterBottom(vec3 rayPos, vec3 rayDir)
    {
        float t = intersectPlaneY(rayPos, rayDir, 0.0);
        vec3 p = rayPos + t*rayDir;
        
        if (p.z > -Z_CLIP_NEAR) return rayAurora(rayPos, rayDir);
        
        vec3 ref = refract(rayDir, -waterNormal(p), WATER_ETA);
        if (ref == vec3(0.0)) {
            return WATER_INSCATTERING; //Total internal reflection
        } else {
            vec3 luminance = rayAurora(p, ref);
            watAttenuate(t, luminance);
            return luminance;
        }
    }
    
    /*MAIN*/
    
    vec3 ray(vec3 rayPos, vec3 rayDir) {
        if (rayPos.y < 0.0) {
            if (rayDir.y > 0.0) {
                return rayWaterBottom(rayPos, rayDir);
            } else {
                return WATER_INSCATTERING;
            }
        } else {
            if (rayDir.y > 0.0) {
                return rayAurora(rayPos, rayDir);
            } else {
                return rayWaterTop(rayPos, rayDir);
            }
        }
    }
    
    void main() {
        //Cull offscreen pixels
        float camOffset = u_pageOffsetY/400.0;
        
        //Set up view ray
        vec3 camPos = vec3(0.0, CAMERA_HEIGHT*(1.0 - camOffset), 0.0);
        vec3 rayDir = normalize(vec3(v_pos.x/u_aspectRatio, v_pos.y, -1.0));
        
        vec3 color = ray(camPos, rayDir);
        
        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 in_pos;
    
    varying vec2 v_pos;

    void main(void) {
        v_pos = in_pos;
        gl_Position = vec4(in_pos, 0.0, 1.0);
    }
</script>

<script type="text/javascript" src="demo.js"></script>
</head>

<body onload="main();">
<canvas id="webglcanvas"></canvas>
<div id="header"></div>
<hr>
<div id="body">
    <div class="title">Who I am</div>
    <div class="content">
        <p>Every night, I look to the stars and attempt to appreciate the vastness of our universe.
        I like to explore worlds; whether they're outside my front door, stored on a computer, or inside my own head.
        To delve into a system, understand it, and to make my mark there; that's what life is all about to me.</p>
        <p>My name is Sam. I'm a technophile, a self-taught programmer, and an avid gamer.
        I was raised behind a keyboard, and I have no idea who I would be without computers.
        For me, they're another world to explore; and the more I learn about them, the more I learn about myself.</p>
        <div class="content-left">
            Age:<br>
            Location:<br>
            Occupation:<br>
        </div>
        <div class="content-right">
            21<br>
            Boulder, Colorado<br>
            Tech Support, IBM<br>
        </div>
    </div>
    <div class="title">Dreaming in Java</div>
    <div class="content">
        <p>Something about programming deeply appeals to me.
        It represents the opportunity not just to explore worlds, but to create them.
        For me, writing code professionally would be a dream come true.</p>
        <h2>Languages:</h2>
        <div class="content-left">
            Java<br>
            GLSL<br>
            JavaScript<br>
            C/C++<br>
            Python<br>
            C#<br>
            Lua<br>
        </div>
        <div class="content-right">
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star-half"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star-half"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star-half"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <i class="fa fa-star-half"></i> <br>
            <i class="fa fa-star"></i> <i class="fa fa-star"></i> <br>
        </div>
    </div>
    <div class="title">Fun is learning</div>
    <div class="content">
        <p>In my free time, I play computer games like Dark Souls, Morrowind, ARMA 3, and Team Fortress 2.
        When I'm not on my computer, I practice historical longsword fencing.
        I also brew my own wines, ciders, and mead.</p>
    </div>
    <div class="title">Contact me</div>
    <div class="content" id="contactinfo">
        <a href="mailto:sam@samrj.com" title="Email">
            <i class="fa fa-envelope"></i></a>
        <a href="http://github.com/SmashMaster" title="GitHub">
            <i class="fa fa-github"></i></a>
        <a href="http://steamcommunity.com/id/SmashMaster" title="Steam">
            <i class="fa fa-steam"></i></a>
    </div>
</div>
<hr>
<div id="footer">
    <p>&copy; 2014 Sam Johnson</p>
    <img src="devl1.png" alt=""><br>
    <p><a href="http://github.com/SmashMaster/smashmaster.github.io">
        This website is open source and published under the MIT license.
    </a></p>
</div>
</body>

</html>
